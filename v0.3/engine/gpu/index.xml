<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GPU overview on Mach: zig game engine &amp; graphics toolkit</title><link>https://machengine.org/v0.3/engine/gpu/</link><description>Recent content in GPU overview on Mach: zig game engine &amp; graphics toolkit</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://machengine.org/v0.3/engine/gpu/index.xml" rel="self" type="application/rss+xml"/><item><title>GPU error handling</title><link>https://machengine.org/v0.3/engine/gpu/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://machengine.org/v0.3/engine/gpu/errors/</guid><description>GPU error handling Asynchronous nature GPUs have largely asynchronous APIs: you build up a command buffer which encodes a number of commands instructing the GPU to do something, and then you ask the GPU to execute that buffer of commands. As a result, errors must be handled asynchronously as well. try isn&amp;rsquo;t going to work here.
Error scopes A concept of error scopes is used, where you can push an error scope onto the stack and pop an error scope.</description></item><item><title>GPU memory management</title><link>https://machengine.org/v0.3/engine/gpu/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://machengine.org/v0.3/engine/gpu/memory/</guid><description>GPU memory management Reference counting GPU objects like gpu.Texture, gpu.Buffer, or any other object which has a .reference, .release and .destroy method - use reference counting.
As Zig developers, we have no qualms with explicit memory management, but GPU memory is perhaps one of the best use-cases for reference counting. GPU objects are reference-counted handles CPU-side, much like a file handle, but often hold references to eachother - while the actual memory lives on the GPU.</description></item></channel></rss>