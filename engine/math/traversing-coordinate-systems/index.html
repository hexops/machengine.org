<!doctype html><html><head><link rel=stylesheet href=https://machengine.org/layouts/default.1b9540ff392b51b0b809690caf746c7ec39a7048990a55170087510406bf5e62.css><link rel=apple-touch-icon sizes=180x180 href=https://machengine.org//apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://machengine.org//favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://machengine.org//favicon-16x16.png><link rel=manifest href=https://machengine.org//site.webmanifest><link rel=mask-icon href=https://machengine.org//safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://machengine.org//assets/font/stylesheet.css><link rel=stylesheet href=https://machengine.org//assets/font/inter/inter.css><script async defer data-domain=hexops.com src=https://machengine.org//opendata.js></script><meta charset=utf-8><title>Traversing coordinate systems | Mach: zig game engine & graphics toolkit</title><link rel=canonical href=https://machengine.org/engine/math/traversing-coordinate-systems/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Traversing coordinate systems"><meta property="og:description" content="A 3D model in a scene, a virtual camera viewing it. But how do vertices ultimately end up on the 2D screen? One transformation at a time!"><meta property="og:type" content="article"><meta property="og:url" content="https://machengine.org/engine/math/traversing-coordinate-systems/"><meta property="og:image" content="https://machengine.org/opengraph/template_hu102e162f47cb7d8ae9eb284939698b9d_62022_d08136abc0f446955f5c780dfbdd61fe.png"><meta property="article:section" content="engine"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://machengine.org/opengraph/template_hu102e162f47cb7d8ae9eb284939698b9d_62022_d08136abc0f446955f5c780dfbdd61fe.png"><meta name=twitter:title content="Traversing coordinate systems"><meta name=twitter:description content="A 3D model in a scene, a virtual camera viewing it. But how do vertices ultimately end up on the 2D screen? One transformation at a time!"></head><body><div class=navbar><div class=content><a href=https://machengine.org// class=logo><div class=img></div></a><div class=subsection><a href=https://machengine.org//engine class=item>Engine</a>
<a href=https://machengine.org//core class=item>Core</a>
<a href=https://machengine.org//pkg class=item>Packages</a>
<a href=https://machengine.org//about class=item>Project</a></div><div class="divider color-border">&nbsp;</div><div class=subsection><a href=https://devlog.hexops.com/categories/mach/ class=item>Devlog</a>
<a href=https://github.com/hexops/mach class=svg-item><img alt=GitHub class=svg-icon src=https://machengine.org//img/github.svg></a>
<a href=https://discord.gg/XNG3NZgCqp class=svg-item><img alt=Discord class=svg-icon src=https://machengine.org//img/discord.svg></a>
<a href=https://github.com/sponsors/slimsag class=donate-button><img alt=Heart class=svg-icon src=https://machengine.org//img/heart.svg>
&nbsp;Donate</a></div></div></div><div class=alert><span><strong>Mach now <em>nominates Zig versions for use!</em></strong> For details check out <a href=https://machengine.org/about/nominated-zig>the docs</a></span></div><div id=content><link rel=stylesheet href=https://machengine.org/layouts/docs.1c549ac5e9eaa1dc4997cd957caa9afec046a45d465b64074e1ec4f88737dd7b.css><main aria-role=main class="main-docs with-alert"><aside><ul><li><a href=https://machengine.org/engine><span>Engine overview</span></a></li><li><a href=https://machengine.org/engine/getting-started><span>Getting started</span></a></li><li><h3><span>Math</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/engine/math>Overview</a></li><li><a href=https://machengine.org/engine/math/coordinate-system>Coordinate system</a></li><li><a href=https://machengine.org/engine/math/traversing-coordinate-systems>Traversing coordinate systems</a></li><li><a href=https://machengine.org/engine/math/matrix-storage>Matrix storage</a></li></ul><li><h3><span>GPU</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/engine/gpu>Overview</a></li><li><a href=https://machengine.org/engine/gpu/memory>Memory management</a></li><li><a href=https://machengine.org/engine/gpu/errors>Error handling</a></li></ul><li><h3><span>Engine</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/engine/roadmap>Roadmap</a></li><li><a href=https://machengine.org/engine/modularity>Modularity</a></li><li><a href=https://machengine.org/engine/stdlib>Standard library</a></li><li><a href=https://machengine.org/about/known-issues>Known issues ‚Æï</a></li></ul></ul></aside><div class=docs><h1 id=traversing-coordinate-systems>Traversing coordinate systems</h1><p>Imagine you&rsquo;ve got a 3D model in a scene, a virtual camera is viewing it. But how do the vertices of the model ultimately end up on the 2D screen? We&rsquo;ll walk through the various <em>coordinate system transformations</em> involved in that in this section, with lots of diagrams and minimal maths!</p><p><a class="img-link centered" href=https://machengine.org/img/vertex-to-pixel.png><img src=https://machengine.org/img/vertex-to-pixel.png></a></p><h2 id=cartesian-coordinate-system-transformations>Cartesian coordinate system transformations</h2><p>First we need to know what a coordinate system transformation is. Imagine a typical 3D grid like you&rsquo;d find in a 3D model editor, such as Blender. That&rsquo;s a 3D <a href=https://en.wikipedia.org/wiki/Cartesian_coordinate_system>cartesian coordinate system</a> - the linear axis in X, Y, and Z dimensions.</p><p>Pick any point on that grid. Then imagine a second grid / coordinate system, overlayed exactly with the other one. But this one you can move, rotate, scale, etc.! As you do, the point you chose on the first grid remains in the same location.. but in the 2nd grid its location changes depending on how you move/rotate/scale the grid!</p><p>The fact that we can take a point anywhere in the first grid, and determine where it would be in the 2nd grid which is moved/rotated/scaled, is a coordinate system transformation and is <em>what a matrix transformation does</em>. Keep this in mind as you think about the transformations we describe later.</p><p><a class="img-link centered" href=https://machengine.org/img/coordinate-system-transformation.png><img src=https://machengine.org/img/coordinate-system-transformation.png></a></p><h2 id=model---world-space>Model -> World space</h2><p>Now that we understand what a coordinate system transformation is, we can begin talking about the first one we need to perform: Model -> World space. Imagine a vertex on a 3D model: the point of a diamond floating in front of a monkey</p><p>This vertex is said to be in the <em>local space of the model</em>, or just &lsquo;model space&rsquo; for short. We get to decide what unit of measurement is used, as long as we&rsquo;re consistent everywhere - so let&rsquo;s say our unit is <em>meters</em>. The position of this vertex at the tip of the monkey&rsquo;s hand is <code>(0, 0, 1)</code> <em>in model space</em>: &lsquo;one meter in front&rsquo; of the monkey, from the perspective of the monkey. It doesn&rsquo;t matter where the monkey is located in the world, that vertex is always at <code>(0, 0, 1)</code> <em>in model space</em> because it is from the perspective of the monkey.</p><p>The <strong>Model matrix</strong> describes how to <em>transform</em> a point <em>in model space</em> into <em>world</em> space, so that we can say &rsquo;the monkey&rsquo;s finger tip&rsquo; is at a specific point in the world, rather than being relative to the monkey&rsquo;s location/rotation/scale/etc.</p><p><a class="img-link centered" href=https://machengine.org/img/model-to-world-space.png><img src=https://machengine.org/img/model-to-world-space.png></a></p><h2 id=world---view-space>World -> View space</h2><p>Next up, we need to convert from <em>world space</em> into <em>view space</em>. Just like how <em>model space</em> is relative to the model, <em>view space</em> is relative to the <em>viewer</em> (i.e. the virtual camera of the scene) - this lets us say &ldquo;this vertex in the 3D world is at (x, y, z) <em>relative to the camera/viewer.</em>&rdquo;</p><p>This is like the opposite of what we just did above: going from Wrench&rsquo;s local model space to world space. Instead, we&rsquo;re going from world space to the camera&rsquo;s local space.</p><h2 id=view---clip-space>View -> Clip space</h2><p>Now that we know where the point is in view space / relative to the camera, we need to transform the vertex into <em>clip space</em>. A <em>projection matrix</em> is used for this, taking 3D points relative to the viewer, and transforming them into a <em>normalized clip space bounding box</em>.</p><p><a class="img-link centered" href=https://machengine.org/img/projection-matrix.png><img src=https://machengine.org/img/projection-matrix.png></a></p><p>Notice how the view frustum above represents a sort of virtual camera lens, with the far plane being much larger than the near plane. The shape of the view frustum is what makes our geometry look like it is in 3D space, objects further away from will appear smaller and objects closer to the camera will appear larger. For 2D games, an <a href=https://i.stack.imgur.com/4bRUu.png>orthographic projection matrix</a> is used instead of the &lsquo;warped&rsquo; perspective projection matrix shown above.</p><p>Also note that the view frustum is where we take into account the aspect ratio and field-of-view. For 2D games, the orthographic projection matrix often e.g. determine how many world-space units map to a single fragment/pixel on screen.</p><p>The clip space volume / bounding box on the right is a concept defined by the underlying graphics APIs and hardware. When a <em>vertex shader</em> runs on every vertex of a 2D/3D model, its goal is to output the position of the vertex <em>in clip space</em>. Unlike our other 3D coordinate spaces so far, clip space is a <em>4D homegenous space</em> - also known as a <a href=https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/>&rsquo;<em>projective space</em>&rsquo;</a>.</p><h3 id=projective-geometry>Projective geometry</h3><p>In all our other 3D coordinate systems so far, we&rsquo;ve been thinking in terms of Euclidean geometry with <code>[x, y, z]</code> points. But in clip space, we need to think in terms of <em>Projective geometry</em> instead with <code>[x, y, z, w]</code>, where ùëä acts basically as a <em>scaling transformation</em> for the 3D coordinate - which will be used in our next transformation.</p><p><a class="img-link centered" href=https://machengine.org/img/2d-projective-space.png><img src=https://machengine.org/img/2d-projective-space.png></a></p><p>The above diagram shows <em>2D projective space</em>, with <code>[x, y, ùëä]</code> - but clip space on GPUs is in <em>3D projective space</em>, with <code>[x, y, z, ùëä]</code> components. It&rsquo;s hard to visualize adding another dimension to the diagram above (a projector which exists in 4D, and projects <em>onto 3D space</em>) - so you&rsquo;ll have to use your imagination - but how ùëä works remains: as it increases, the coordinate <code>[x, y, z]</code> <em>expands</em> (scales up) and when ùëä decreases, the coordinate <code>[x, y, z]</code> <em>shrinks</em> (scales down). Each vertex can have its own ùëä value, and so each vertex effectively lives in its own unique projective clip space. The ùëä is basically a <em>scaling transformation</em> for the 3D coordinate.</p><h3 id=clip-space-continued>Clip space continued</h3><p>The vertex shader (i.e., you) are responsible for producing that four-dimensional vertex position <em>in clip space</em>. Vertices form primitive shapes (like triangles), and when they go beyond the bounds of that <em>clip space volume / bounding box</em> in the diagram shown earlier, or if they intersect it, the GPU will <em>clip them</em>. You can literally think of a piece of paper in the shape of a triangle, then imagine using scissors to <em>clip</em> a portion of the triangle off!</p><p>Anything that is outside the clip space volume / bounding box, any points that do not pass the following tests, will be <em>clipped</em>:</p><ul><li>‚àíp.ùëä ‚â§ p.x ‚â§ p.ùëä</li><li>‚àíp.ùëä ‚â§ p.y ‚â§ p.ùëä</li><li>0 ‚â§ p.z ‚â§ p.ùëä (depth clipping, optional)</li></ul><p>GPUs use the clip volume to determine what actually needs to be rendered. Fragments/pixels/vertices outside of this clip volume, anything off-screen or behind the viewer/camera, do not need to be rendered.</p><h2 id=clip-space---ndc>Clip space -> NDC</h2><p>Finally it is time to perform the <em>perspective divide</em>, and get our clip-space coordinates into <em>normalized device coordinates (NDC)</em>.</p><p><a class="img-link centered" href=https://machengine.org/img/clip-space-to-ndc.png><img src=https://machengine.org/img/clip-space-to-ndc.png></a></p><p>Much like clip space, NDC is a bounding box:</p><ul><li>-1.0 ‚â§ x ‚â§ 1.0</li><li>-1.0 ‚â§ y ‚â§ 1.0</li><li>0.0 ‚â§ z ‚â§ 1.0</li><li>The bottom-left corner is at (-1.0, -1.0, z).</li></ul><p>To convert from clip space -> NDC, we perform the perspective divide, take the (x, y, z) components and dividing each by the ùëä component, this converts a 4D clip-space coordinate into 3D space once again.</p><h2 id=rasterization>Rasterization</h2><p>Multiple vertices in normalized device coordinates make up primitive shapes (like triangles), which the GPU performs <a href=https://www.w3.org/TR/webgpu/#rasterization>rasterization</a> on, rendering to texels in the framebuffer, depth buffer, etc. This involves many other aspects we won&rsquo;t go into here: multisampling, depth testing, front/back-face culling, stenciling, scissor operations, and more! It also involves running your <em>fragment shader</em> for each fragment that would end up in the framebuffer and, ultimately, as a pixel on the screen.</p><p>What we will explain here is how normalized device coordinates end up mapping to framebuffer space, though!</p><h2 id=normalized-device-coordinates>Normalized device coordinates</h2><p>Here you can see how normalized device coordinates would map to e.g. a fullscreen window.</p><p><a class="img-link centered" href=https://machengine.org/img/normalized-device-coordinates.png><img src=https://machengine.org/img/normalized-device-coordinates.png></a></p><p>(x=0, y=0) is always the center of the framebuffer, whether it&rsquo;s a window, a fullscreen application, running at any resolution - it&rsquo;s always the center! (-1, -1) is always the bottom-left, and (1, 1) the top-right. The Z axis extends from z=0 (the surface of your screen) <em>into</em> it at z=1.</p><h2 id=framebuffer-coordinates>Framebuffer coordinates</h2><p><a class="img-link centered" href=https://machengine.org/img/framebuffer-coordinates.png><img src=https://machengine.org/img/framebuffer-coordinates.png></a></p><p>It&rsquo;s worth noting that <em>framebuffer coordinates</em> are not always the same thing as <em>pixels</em>. Framebuffers hold <em>texels</em>. As displays became higher and higher in their resolutions, OS developers decided that <em>physical pixels</em> on your screen and <em>virtual pixels</em> used to position/place things on screen, would be different concepts. Blegh!</p><p>For example.. you may create a window on your screen which is 720x480px. On a machine with an older display/monitor/OS version, that may mean you get a 720x480 resolution <em>framebuffer</em>, everything matches, great! But on a newer system with a HDPI display, you may find that your 720x480px window has a framebuffer resolution of <em>twice that</em>, at 1440x960! In this case, one <em>virtual pixel</em> maps to four (2x2) <em>physical pixels</em> on the display!</p><p>macOS, Windows, Linux, and cellphones all have this distinction today between physical and virtual pixels, with various options that affect the mapping of virtual->physical. Some platforms (e.g. Linux) even allow for <em>fractional scaling</em>, where e.g. a virtual pixel may be made up of say 2.1 physical pixels, so your 720px wide window might end up being 1512px wide!</p><p>The key thing here to keep in mind is just that the <em>window resolution != framebuffer resolution</em>, you&rsquo;re always rendering pixels/texels into the framebuffer, but there&rsquo;s no guarantee a pixel/texel in the framebuffer will be displayed as 1 physical pixel on the screen. You may need to convert between the two frequently.</p><h2 id=you-are-now-a-multidimensional-wizard>You are now a multidimensional wizard!</h2><p>You&rsquo;re now capable of traversing the various coordinate systems, to 4D space and back again - or, at least, hopefully you have a clearer picture of the parts involved in getting a <em>vertex in the 3D world</em> to end up on the screen at the end of the day.</p></div><div class=toc><h3>Table of contents</h3><nav id=TableOfContents><ul><li><a href=#cartesian-coordinate-system-transformations>Cartesian coordinate system transformations</a></li><li><a href=#model---world-space>Model -> World space</a></li><li><a href=#world---view-space>World -> View space</a></li><li><a href=#view---clip-space>View -> Clip space</a><ul><li><a href=#projective-geometry>Projective geometry</a></li><li><a href=#clip-space-continued>Clip space continued</a></li></ul></li><li><a href=#clip-space---ndc>Clip space -> NDC</a></li><li><a href=#rasterization>Rasterization</a></li><li><a href=#normalized-device-coordinates>Normalized device coordinates</a></li><li><a href=#framebuffer-coordinates>Framebuffer coordinates</a></li><li><a href=#you-are-now-a-multidimensional-wizard>You are now a multidimensional wizard!</a></li></ul></nav></div></main><div class=footer><a href=https://hexops.com/privacy>Privacy matters</a><p><a href=https://github.com/hexops/machengine.org/archive/refs/heads/gh-pages.zip>offline version of this site</a> | <a href=https://machengine.org//about#improve-this-site>Improve this site</a> | <a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a> | <a href=https://devlog.hexops.com/>Hexops' devlog</a></p></div></div></body></html>