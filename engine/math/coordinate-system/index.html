<!doctype html><html><head><link rel=stylesheet href=https://machengine.org/layouts/default.1b9540ff392b51b0b809690caf746c7ec39a7048990a55170087510406bf5e62.css><link rel=apple-touch-icon sizes=180x180 href=https://machengine.org//apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://machengine.org//favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://machengine.org//favicon-16x16.png><link rel=manifest href=https://machengine.org//site.webmanifest><link rel=mask-icon href=https://machengine.org//safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://machengine.org//assets/font/stylesheet.css><link rel=stylesheet href=https://machengine.org//assets/font/inter/inter.css><script async defer data-domain=hexops.com src=https://machengine.org//opendata.js></script><meta charset=utf-8><title>Coordinate system | Mach: zig game engine & graphics toolkit</title><link rel=canonical href=https://machengine.org/engine/math/coordinate-system/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Coordinate system"><meta property="og:description" content="Mach uses a (+Y up, left-handed) coordinate system, matching WebGPU, Metal, D3D12, and Unity3D. Included is a helpful diagram for you."><meta property="og:type" content="article"><meta property="og:url" content="https://machengine.org/engine/math/coordinate-system/"><meta property="og:image" content="https://machengine.org/opengraph/template_hu102e162f47cb7d8ae9eb284939698b9d_62022_e6fd66d52857873b97486c9d9a65a155.png"><meta property="article:section" content="engine"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://machengine.org/opengraph/template_hu102e162f47cb7d8ae9eb284939698b9d_62022_e6fd66d52857873b97486c9d9a65a155.png"><meta name=twitter:title content="Coordinate system"><meta name=twitter:description content="Mach uses a (+Y up, left-handed) coordinate system, matching WebGPU, Metal, D3D12, and Unity3D. Included is a helpful diagram for you."></head><body><div class=navbar><div class=content><a href=https://machengine.org// class=logo><div class=img></div></a><div class=subsection><a href=https://machengine.org//engine class=item>Engine</a>
<a href=https://machengine.org//core class=item>Core</a>
<a href=https://machengine.org//pkg class=item>Packages</a>
<a href=https://machengine.org//about class=item>Project</a></div><div class="divider color-border">&nbsp;</div><div class=subsection><a href=https://devlog.hexops.com/categories/mach/ class=item>Devlog</a>
<a href=https://github.com/hexops/mach class=svg-item><img alt=GitHub class=svg-icon src=https://machengine.org//img/github.svg></a>
<a href=https://discord.gg/XNG3NZgCqp class=svg-item><img alt=Discord class=svg-icon src=https://machengine.org//img/discord.svg></a>
<a href=https://github.com/sponsors/slimsag class=donate-button><img alt=Heart class=svg-icon src=https://machengine.org//img/heart.svg>
&nbsp;Donate</a></div></div></div><div class=alert><span><strong>Mach v0.2 has been released!</strong> For all the details check out <a href=https://devlog.hexops.com/2023/mach-v0.2-released/>the announcement</a></span></div><div id=content><link rel=stylesheet href=https://machengine.org/layouts/docs.eba24e7b90282072fe2e748d2511c23c5000ad5f00b0ef3bf03f8ee20348f6e6.css><main aria-role=main class="main-docs with-alert"><aside><ul><li><a href=https://machengine.org/engine><span>Engine overview</span></a></li><li><a href=https://machengine.org/engine/roadmap><span>Roadmap</span></a></li><li><a href=https://machengine.org/about/known-issues><span>Known issues ⮕</span></a></li><li><a href=https://machengine.org/engine/modularity><span>Modularity</span></a></li><li><a href=https://machengine.org/engine/stdlib><span>Standard library</span></a></li><li><h3><span>Math</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/engine/math>Overview</a></li><li><a href=https://machengine.org/engine/math/coordinate-system>Coordinate system</a></li><li><a href=https://machengine.org/engine/math/matrix-storage>Matrix storage</a></li></ul><li><h3><span>GPU</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/engine/gpu>Overview</a></li><li><a href=https://machengine.org/engine/gpu/memory>Memory management</a></li><li><a href=https://machengine.org/engine/gpu/errors>Error handling</a></li></ul></ul></aside><div class=docs><h1 id=coordinate-system>Coordinate system</h1><p>This page briefly covers Mach&rsquo;s coordinate systems; then it delves into <em>traversing coordinate systems</em> explaining at a high-level (and with very minimal maths) how e.g. a polygon in a 3D model in the scene goes through a bunch of coordinate system transforms before finally ending up as a pixel on the screen.</p><p>You don&rsquo;t have to read this whole page, but it might be worth skimming and taking a look at the diagrams!</p><h2 id=world-space>World space</h2><p><a href=https://machengine.org/img/coordinate-system.png?v2><img src=https://machengine.org/img/coordinate-system.png?v2></a></p><p>3D models and 2D sprites are said to exist in <strong>world space</strong>, Mach uses a &lsquo;<strong>+Y up, left-handed</strong>&rsquo; coordinate system to represent objects in space. To visualize it, imagine your own eyes are the camera. Hold your left hand out in front of you in a thumbs-up pose, as if you were holding a stick:</p><ul><li>X goes through the back side of your palm, towards your fingernails</li><li>Y goes through the bottom of your hand towards the tip of your thumb</li><li>Z goes through your eyes and towards your thumb</li><li>Positive rotation values follow the direction of your fingers curled around the stick (any axis)</li></ul><h2 id=quick-reference>Quick reference</h2><table><thead><tr><th>What</th><th>Coordinate system</th></tr></thead><tbody><tr><td>World space</td><td>+Y up, left-handed</td></tr><tr><td>Texture coordinates</td><td>+Y down; (0, 0) is at the top-left corner and the first texel in memory address order. (1, 1) is the last texel in memory address order.</td></tr><tr><td>Framebuffer coordinates</td><td>+Y down; (0, 0) is at the top-left corner</td></tr><tr><td>Normalized device coordinates (NDC)</td><td>+Y up; (-1, -1) is at the bottom-left corner</td></tr></tbody></table><h2 id=mach-vs-other-software>Mach vs. other software</h2><p>If you are familiar with other software / APIs, the following comparison tables may be helpful:</p><p><a href=https://machengine.org/img/coord-comparison.png><img src=https://machengine.org/img/coord-comparison.png></a>
<a href=https://machengine.org/img/texcoord-comparison.png><img src=https://machengine.org/img/texcoord-comparison.png></a></p><h2 id=traversing-coordinate-systems>Traversing coordinate systems</h2><p>Suppose that you have a 3D model placed in a scene, and a virtual camera is viewing it. How do the vertices of that model ultimately end up on the 2D screen? We&rsquo;ll walk through this below, one coordinate system transformation at a time!</p><p><a href=https://machengine.org/img/vertex-to-pixel.png><img src=https://machengine.org/img/vertex-to-pixel.png></a></p><h3 id=cartesian-coordinate-system-transformations>Cartesian coordinate system transformations</h3><p>First we need to know what a coordinate system transformation is. Imagine a typical 3D grid like you&rsquo;d find in a 3D model editor, such as Blender. That&rsquo;s a 3D <a href=https://en.wikipedia.org/wiki/Cartesian_coordinate_system>cartesian coordinate system</a> - the linear axis in X, Y, and Z dimensions.</p><p>Pick any point on that grid. Then imagine a second grid / coordinate system, overlayed exactly with the other one. But this one you can move, rotate, scale, etc.! As you do, the point you chose on the first grid remains in the same location.. but in the 2nd grid its location changes depending on how you move/rotate/scale the grid!</p><p>The fact that we can take a point anywhere in the first grid, and determine where it would be in the 2nd grid which is moved/rotated/scaled, is a coordinate system transformation and is <em>what a matrix transformation does</em>. Keep this in mind as you think about the transformations we describe later.</p><p><a href=https://machengine.org/img/coordinate-system-transformation.png><img src=https://machengine.org/img/coordinate-system-transformation.png></a></p><h3 id=model---world-space>Model -> World space</h3><p>Now that we understand what a coordinate system transformation is, we can begin talking about the first one we need to perform: Model -> World space. Imagine a vertex on a 3D model: the point of a diamond floating in front of a monkey</p><p>This vertex is said to be in the <em>local space of the model</em>, or just &lsquo;model space&rsquo; for short. We get to decide what unit of measurement is used, as long as we&rsquo;re consistent everywhere - so let&rsquo;s say our unit is <em>meters</em>. The position of this vertex at the tip of the monkey&rsquo;s hand is <code>(0, 0, 1)</code> <em>in model space</em>: &lsquo;one meter in front&rsquo; of the monkey, from the perspective of the monkey. It doesn&rsquo;t matter where the monkey is located in the world, that vertex is always at <code>(0, 0, 1)</code> <em>in model space</em> because it is from the perspective of the monkey.</p><p>The <strong>Model matrix</strong> describes how to <em>transform</em> a point <em>in model space</em> into <em>world</em> space, so that we can say &rsquo;the monkey&rsquo;s finger tip&rsquo; is at a specific point in the world, rather than being relative to the monkey&rsquo;s location/rotation/scale/etc.</p><p><a href=https://machengine.org/img/model-to-world-space.png><img src=https://machengine.org/img/model-to-world-space.png></a></p><h3 id=world---view-space>World -> View space</h3><p>Next up, we need to convert from <em>world space</em> into <em>view space</em>. Just like how <em>model space</em> is relative to the model, <em>view space</em> is relative to the <em>viewer</em> (i.e. the virtual camera of the scene) - this lets us say &ldquo;this vertex in the 3D world is at (x, y, z) <em>relative to the camera/viewer.</em>&rdquo;</p><p>This is like the opposite of what we just did above: going from Wrench&rsquo;s local model space to world space. Instead, we&rsquo;re going from world space to the camera&rsquo;s local space.</p><h3 id=view---clip-space>View -> Clip space</h3><p>Now that we know where the point is in view space / relative to the camera, we need to transform the vertex into <em>clip space</em>. A <em>projection matrix</em> is used for this, taking 3D points relative to the viewer, and transforming them into a <em>normalized clip space bounding box</em>.</p><p><a href=https://machengine.org/img/projection-matrix.png><img src=https://machengine.org/img/projection-matrix.png></a></p><p>Notice how the view frustum above represents a sort of virtual camera lens, with the far plane being much larger than the near plane. The shape of the view frustum is what makes our geometry look like it is in 3D space, objects further away from will appear smaller and objects closer to the camera will appear larger. For 2D games, an <a href=https://i.stack.imgur.com/4bRUu.png>orthographic projection matrix</a> is used instead of the &lsquo;warped&rsquo; perspective projection matrix shown above.</p><p>Also note that the view frustum is where we take into account the aspect ratio and field-of-view. For 2D games, the orthographic projection matrix often e.g. determine how many world-space units map to a single fragment/pixel on screen.</p><p>The clip space volume / bounding box on the right is a concept defined by the underlying graphics APIs and hardware. When a <em>vertex shader</em> runs on every vertex of a 2D/3D model, its goal is to output the position of the vertex <em>in clip space</em>. Unlike our other 3D coordinate spaces so far, clip space is a <em>4D homegenous space</em> - also known as a <a href=https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/>&rsquo;<em>projective space</em>&rsquo;</a>.</p><h4 id=projective-geometry>Projective geometry</h4><p>In all our other 3D coordinate systems so far, we&rsquo;ve been thinking in terms of Euclidean geometry with <code>[x, y, z]</code> points. But in clip space, we need to think in terms of <em>Projective geometry</em> instead with <code>[x, y, z, w]</code>, where 𝑊 acts basically as a <em>scaling transformation</em> for the 3D coordinate - which will be used in our next transformation.</p><p><a href=https://machengine.org/img/2d-projective-space.png><img src=https://machengine.org/img/2d-projective-space.png></a></p><p>The above diagram shows <em>2D projective space</em>, with <code>[x, y, 𝑊]</code> - but clip space on GPUs is in <em>3D projective space</em>, with <code>[x, y, z, 𝑊]</code> components. It&rsquo;s hard to visualize adding another dimension to the diagram above (a projector which exists in 4D, and projects <em>onto 3D space</em>) - so you&rsquo;ll have to use your imagination - but how 𝑊 works remains: as it increases, the coordinate <code>[x, y, z]</code> <em>expands</em> (scales up) and when 𝑊 decreases, the coordinate <code>[x, y, z]</code> <em>shrinks</em> (scales down). Each vertex can have its own 𝑊 value, and so each vertex effectively lives in its own unique projective clip space. The 𝑊 is basically a <em>scaling transformation</em> for the 3D coordinate.</p><h4 id=clip-space-continued>Clip space continued</h4><p>The vertex shader (i.e., you) are responsible for producing that four-dimensional vertex position <em>in clip space</em>. Vertices form primitive shapes (like triangles), and when they go beyond the bounds of that <em>clip space volume / bounding box</em> in the diagram shown earlier, or if they intersect it, the GPU will <em>clip them</em>. You can literally think of a piece of paper in the shape of a triangle, then imagine using scissors to <em>clip</em> a portion of the triangle off!</p><p>Anything that is outside the clip space volume / bounding box, any points that do not pass the following tests, will be <em>clipped</em>:</p><ul><li>−p.𝑊 ≤ p.x ≤ p.𝑊</li><li>−p.𝑊 ≤ p.y ≤ p.𝑊</li><li>0 ≤ p.z ≤ p.𝑊 (depth clipping, optional)</li></ul><p>GPUs use the clip volume to determine what actually needs to be rendered. Fragments/pixels/vertices outside of this clip volume, anything off-screen or behind the viewer/camera, do not need to be rendered.</p><h3 id=clip-space---ndc>Clip space -> NDC</h3><p>Finally it is time to perform the <em>perspective divide</em>, and get our clip-space coordinates into <em>normalized device coordinates (NDC)</em>.</p><p><a href=https://machengine.org/img/clip-space-to-ndc.png><img src=https://machengine.org/img/clip-space-to-ndc.png></a></p><p>Much like clip space, NDC is a bounding box:</p><ul><li>-1.0 ≤ x ≤ 1.0</li><li>-1.0 ≤ y ≤ 1.0</li><li>0.0 ≤ z ≤ 1.0</li><li>The bottom-left corner is at (-1.0, -1.0, z).</li></ul><p>To convert from clip space -> NDC, we perform the perspective divide, take the (x, y, z) components and dividing each by the 𝑊 component, this converts a 4D clip-space coordinate into 3D space once again.</p><h3 id=rasterization>Rasterization</h3><p>Multiple vertices in normalized device coordinates make up primitive shapes (like triangles), which the GPU performs <a href=https://www.w3.org/TR/webgpu/#rasterization>rasterization</a> on, rendering to fragments in the framebuffer, depth buffer, etc. This involves many other aspects we won&rsquo;t go into here: multisampling, depth testing, front/back-face culling, stenciling, scissor operations, and more! It also involves running your <em>fragment shader</em> for each fragment that would end up in the framebuffer and, ultimately, as a pixel on the screen.</p><p>What we will explain here is how normalized device coordinates end up mapping to framebuffer space, though!</p><h3 id=normalized-device-coordinates>Normalized device coordinates</h3><p>Here you can see how normalized device coordinates would map to e.g. a fullscreen window.</p><p><a href=https://machengine.org/img/normalized-device-coordinates.png><img src=https://machengine.org/img/normalized-device-coordinates.png></a></p><p>(x=0, y=0) is always the center of the framebuffer, whether it&rsquo;s a window, a fullscreen application, running at any resolution - it&rsquo;s always the center! (-1, -1) is always the bottom-left, and (1, 1) the top-right. The Z axis extends from z=0 (the surface of your screen) <em>into</em> it at z=1.</p><h3 id=framebuffer-coordinates>Framebuffer coordinates</h3><p><a href=https://machengine.org/img/framebuffer-coordinates.png><img src=https://machengine.org/img/framebuffer-coordinates.png></a></p><p>It&rsquo;s worth noting that <em>framebuffer coordinates</em> are not always the same thing as <em>pixels</em>. Framebuffers hold <em>fragments</em>, the smallest possible little dot of light, pixel is also a fine name! But as displays became ever higher and higher in their resolutions, OS developers decided that <em>physical pixels</em> (fragments) and <em>virtual pixels</em> used to position things on screen, would be different concepts. Blegh!</p><p>For example.. you may create a window on your screen which is 720x480px. On a machine with an older display/monitor/OS version, that may mean you get a 720x480px <em>framebuffer</em>, everything matches, great! But on a newer system with a HDPI display, you may find that your 720x480px window has a framebuffer resolution of <em>twice that</em>, at 1440x960px(!) because one <em>virtual pixel</em> maps to four (2x2) <em>physical pixels</em> on the display!</p><p>macOS, Windows, Linux, and cellphones all have this distinction today between physical and virtual pixels. Some platforms (e.g. Linux) allow for <em>fractional scaling</em>, where e.g. a virtual pixel may be made up of say 2.1 physical pixels, so your 720px wide window might end up being 1512px wide, funky!</p><p>The key thing here to keep in mind is just that the <em>window resolution != framebuffer resolution</em>, you&rsquo;re always rendering pixels into the framebuffer, and that resolution may not be the same as the window size itself - so you may need to convert between the two.</p><h3 id=you-are-now-a-multidimensional-wizard>You are now a multidimensional wizard!</h3><p>You&rsquo;re now capable of traversing the various coordinate systems, to 4D space and back again - or, at least, hopefully you have a clearer picture of the parts involved in getting a <em>vertex in the 3D world</em> to end up on the screen at the end of the day.</p></div><div class=toc><h3>Table of contents</h3><nav id=TableOfContents><ul><li><a href=#world-space>World space</a></li><li><a href=#quick-reference>Quick reference</a></li><li><a href=#mach-vs-other-software>Mach vs. other software</a></li><li><a href=#traversing-coordinate-systems>Traversing coordinate systems</a><ul><li><a href=#cartesian-coordinate-system-transformations>Cartesian coordinate system transformations</a></li><li><a href=#model---world-space>Model -> World space</a></li><li><a href=#world---view-space>World -> View space</a></li><li><a href=#view---clip-space>View -> Clip space</a></li><li><a href=#clip-space---ndc>Clip space -> NDC</a></li><li><a href=#rasterization>Rasterization</a></li><li><a href=#normalized-device-coordinates>Normalized device coordinates</a></li><li><a href=#framebuffer-coordinates>Framebuffer coordinates</a></li><li><a href=#you-are-now-a-multidimensional-wizard>You are now a multidimensional wizard!</a></li></ul></li></ul></nav></div></main><div class=footer><a href=https://hexops.com/privacy>Privacy matters</a><p><a href=https://github.com/hexops/machengine.org/archive/refs/heads/gh-pages.zip>offline version of this site</a> | <a href=https://machengine.org//about#improve-this-site>Improve this site</a> | <a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a> | <a href=https://devlog.hexops.com/>Hexops' devlog</a></p></div></div></body></html>