<!doctype html><html><head><link rel=stylesheet href=https://machengine.org/layouts/default.bb15466819d3fbaf312db7ece8726d7131ba9ed50eeb5e347de909b3f0b89c48.css><link rel=apple-touch-icon sizes=180x180 href=https://machengine.org//apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://machengine.org//favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://machengine.org//favicon-16x16.png><link rel=manifest href=https://machengine.org//site.webmanifest><link rel=mask-icon href=https://machengine.org//safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://machengine.org//assets/font/stylesheet.css><link rel=stylesheet href=https://machengine.org//assets/font/inter/inter.css><script async defer data-domain=hexops.com src=https://machengine.org//opendata.js></script><meta charset=utf-8><title>Object system: objects | Mach: zig game engine & graphics toolkit</title><link rel=canonical href=https://machengine.org/docs/object/objects/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Object system: objects"><meta property="og:description" content="Mach objects represent everything from virtual objects like textures and shaders, to visual in-game objects and more!"><meta property="og:type" content="article"><meta property="og:url" content="https://machengine.org/docs/object/objects/"><meta property="og:image" content="https://machengine.org/opengraph/template_hu102e162f47cb7d8ae9eb284939698b9d_62022_43bdea261f4b6b594d57145704837e28.png"><meta property="article:section" content="docs"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://machengine.org/opengraph/template_hu102e162f47cb7d8ae9eb284939698b9d_62022_43bdea261f4b6b594d57145704837e28.png"><meta name=twitter:title content="Object system: objects"><meta name=twitter:description content="Mach objects represent everything from virtual objects like textures and shaders, to visual in-game objects and more!"></head><body><div class=navbar><div class=content><a href=https://machengine.org// class=logo><div class=img></div></a><div class=subsection><a href=https://machengine.org//docs class=item>Docs</a>
<a href=https://machengine.org//about class=item>Project</a></div><div class="divider color-border">&nbsp;</div><div class=subsection><a href=https://devlog.hexops.com/categories/mach/ class=item>Devlog</a>
<a href=https://github.com/hexops/mach class=svg-item><img alt=GitHub class=svg-icon src=https://machengine.org//img/github.svg></a>
<a href=https://discord.gg/XNG3NZgCqp class=svg-item><img alt=Discord class=svg-icon src=https://machengine.org//img/discord.svg></a>
<a href=https://github.com/sponsors/emidoots class=donate-button><img alt=Heart class=svg-icon src=https://machengine.org//img/heart.svg>
&nbsp;Donate</a></div></div></div><div id=content><link rel=stylesheet href=https://machengine.org/layouts/docs.145a7d0caf5b3345083bed4fb10383d5bbda5c3cfd5a83cc7a153b0afbd8b2eb.css><main aria-role=main class=main-docs><aside><ul><li><a href=https://machengine.org/docs><span>Overview</span></a></li><li><a href=https://machengine.org/docs/getting-started><span>Getting started</span></a></li><li><h3><span>Object system</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/docs/object>Overview</a></li><li><a href=https://machengine.org/docs/object/modules>Modules</a></li><li><a href=https://machengine.org/docs/object/systems>Systems</a></li><li><a href=https://machengine.org/docs/object/objects>Objects</a></li><li><a href=https://machengine.org/docs/object/relations>Relations</a></li></ul><li><h3><span>Math</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/docs/math>Overview</a></li><li><a href=https://machengine.org/docs/math/coordinate-system>Coordinate system</a></li><li><a href=https://machengine.org/docs/math/traversing-coordinate-systems>Traversing coordinate systems</a></li><li><a href=https://machengine.org/docs/math/matrix-storage>Matrix storage</a></li></ul><li><h3><span>GPU</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/docs/gpu>Overview</a></li><li><a href=https://machengine.org/docs/gpu/memory>Memory management</a></li><li><a href=https://machengine.org/docs/gpu/errors>Error handling</a></li></ul><li><h3><span>General</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/docs/roadmap>Roadmap</a></li><li><a href=https://machengine.org/docs/modularity>Modularity</a></li><li><a href=https://machengine.org/docs/stdlib>Standard library</a></li><li><a href=https://machengine.org/docs/zig-version>Zig version</a></li><li><a href=https://machengine.org/docs/nominated-zig>Nominated Zig</a></li></ul></ul></aside><div class=docs><h1 id=object-system-objects>Object system: objects</h1><p>Mach objects are a key concept of <a href=../>the Mach object system</a> and are used to represent everything from virtual objects like textures and shaders, to visual in-game objects and more!</p><h1 id=declaring-objects>Declaring objects</h1><p>Objects are declared just like <a href=../modules#modules-can-have-_global-state_>a modules&rsquo; global state fields</a> - the only difference is the data type of the struct field. For example, here is a dynamically-sized list of monster objects where each monster can have <code>health</code> and <code>damage</code> values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> mach_module <span style=color:#f92672>=</span> .app;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>monsters<span style=color:#f92672>:</span> mach.Objects(<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    health<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>    damage<span style=color:#f92672>:</span> <span style=color:#66d9ef>f32</span>,
</span></span><span style=display:flex><span>}),
</span></span></code></pre></div><p>A Mach module can declare as many lists of object as they like using different field names.</p><p><strong>Mach objects are fully addressible</strong>, it&rsquo;s possible to walk over all the Mach modules in a program, reflect on which objects they have, what their data types are, create/destroy objects, inspect objects&rsquo; values, etc. all at runtime - which is central to enabling debug/GUI tooling, usage from other programming languages, network-synchronized objects, objects serialized to disk, etc.</p><h1 id=using-objects>Using objects</h1><p>Lists of objects, like <code>monsters</code> in the example above, are automatically initialized and ready-to-use by Mach. This means you can work with objects like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> init(app<span style=color:#f92672>:</span> <span style=color:#f92672>*</span>App) <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    app.monsters.lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> app.monsters.unlock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a new monster object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> new_monster_id<span style=color:#f92672>:</span> mach.ObjectID <span style=color:#f92672>=</span> app.monsters.new(.{
</span></span><span style=display:flex><span>        .health <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>,
</span></span><span style=display:flex><span>        .damage <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Print the monsters&#39; health
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> new_monster <span style=color:#f92672>=</span> app.monsters.get(new_monster_id);
</span></span><span style=display:flex><span>    std.debug.print(<span style=color:#e6db74>&#34;monster health: {}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, .{new_monster.health});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Give the monster 2x damage!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    new_monster.damage <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    app.monsters.set(new_monster_id, new_monster); <span style=color:#75715e>// save the change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=performance--philosophy>Performance & philosophy</h2><p>The first thing we should talk about is performance and memory optimization. <code>mach.Objects</code> isn&rsquo;t just a dynamic array of structs - it actually stores all of the fields of the object independently (struct-of-arrays, same as a <code>std.MultiArrayList(T)</code>), so internally it&rsquo;s <em>as if</em> there were a list of <code>[]f32</code> for the <code>health</code> of all objects, and another list of <code>[]f32</code> for the <code>damage</code> of all objects.</p><p>This design decision helps reduce the memory overhead of storing many objects, by eliminating <em>padding</em> between struct fields - which can <em>greatly</em> improve CPU cache efficiency and overall application performance. For more details you can watch <a href=https://vimeo.com/649009599>Andrew Kelley&rsquo;s Practical DOD talk</a> which teaches practical ways to apply <em>data-oriented design</em>.</p><p>A core design decision of Mach&rsquo;s object system is to encourage you to <em>write code that operates on many objects at once</em>. For example, instead of writing a function that manipulates a single object (like how a Java programmer might), we instead prefer to store all our objects in a big array, and write a function that operates over all of them all at once. This can <em>massively</em> improve performance by improving the odds that objects are in CPU L1/L2/L3 caches, reducing function call overhead, and more.</p><p><strong>System functions in Mach are restricted from having arbitrary arguments</strong> in part to encourage you to write functions that operate on <em>many objects at once</em>, and to write modules that <em>communicate through objects</em>. Rather than calling another module&rsquo;s functions to cause an effect, you should assume the module&rsquo;s functions will run in the future - and you just need to create/modify/update an object to create the desired effect.</p><h2 id=object-ids>Object IDs</h2><p>The first thing you might notice about the code snippet above is that when you create a new object, you get an <em>object ID</em> back:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>    <span style=color:#66d9ef>const</span> new_monster_id<span style=color:#f92672>:</span> mach.ObjectID <span style=color:#f92672>=</span> app.monsters.new(.{
</span></span><span style=display:flex><span>        .health <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>,
</span></span><span style=display:flex><span>        .damage <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><p>Object IDs are just stable integer identifiers, containing <em>a ton of information</em> in them:</p><ul><li>An array index that can be used to O(1) lookup the actual data / struct fields of the object.</li><li>The generation (or &lsquo;version&rsquo;) of the object, enabling detecting use-after-object-delete in many (but not all) cases.</li><li>Which module the object came from, allowing looking up type information about the object - or which module it came from - just from its ID.</li><li>Which exact list of objects in a module the object came from, allowing looking up detailed type information or the object&rsquo;s name - which enables debugging and type safety when passing opaque IDs around.</li></ul><h2 id=memory-allocation>Memory allocation</h2><p>Internally, a <code>mach.Objects()</code> list maintains <em>a recycling bin</em> of objects: when a <code>.new()</code> object is requested, it looks in the recycling bin to see if we have an index in the array which was a previously <code>.delete()</code>ed object. This allows for rapidly creating/destroying massive quantities of objects with very little overhead.</p><p>Additionally, since Mach has insights into the object lists it has the opportunity to analyze the required memory allocation as you e.g. play through your game, save that information to disk and compile it into future builds of the game - to allocate just the right amount in the future ahead of time for even fewer runtime memory allocations and better performance.</p><h2 id=synchronization-and-multi-threading>Synchronization and multi-threading</h2><p>You may have noticed that we have this code around our usage of the <code>monsters</code> list:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>    app.monsters.lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> app.monsters.unlock();
</span></span></code></pre></div><p>All <code>mach.Objects</code> have a read-write lock protecting them.</p><p>This enables multiple threads, each running independent Mach module system functions, to coordinate with one-another without data race conditions. For example, you may have some game logic which works on monsters, while having a background thread handling network packets to keep monsters across the network synchronized, while also having a debug editor for your game allowing you to edit monsters&rsquo; values at any time - all being synchronized by this read-write lock.</p><p>Importantly, since all <code>mach.Objects</code> by convention have a read-write lock which should be held when working with them, it is possible to work with <em>arbitrary objects</em> safely without knowing what they are or under what contract they can be manipulated. For example, a GUI editor can read or write arbitrary objects&rsquo; values safely without knowing anything about that type of object - all at runtime.</p><p><strong>Performance note:</strong> Since it is a read-write lock, multiple threads can read at once. Mutexes are cheap as long as there is no thread contention, and <code>mach.Objects</code> lists are designed to be generally large in size and performant in other ways - so this works out and keeps sometimes quite complex multi-threaded code simple to reason about.</p><h2 id=iterating-objects>Iterating objects</h2><p>A very common thing to do is iterate all objects, which you can do like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> tick(app<span style=color:#f92672>:</span> <span style=color:#f92672>*</span>App) <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    app.monsters.lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> app.monsters.unlock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Iterate over each monster and do something with them
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> slice <span style=color:#f92672>=</span> app.monsters.slice();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (slice.next()) <span style=color:#f92672>|</span>monster_id<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> monster <span style=color:#f92672>=</span> slice.get(monster_id);
</span></span><span style=display:flex><span>        monster.health <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// they can never die!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        slice.set(monster_id, monster);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// But we will delete them anyway :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (monster.health <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) slice.delete(monster_id);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note: since <code>mach.Objects</code> maintains a recycling bin, you can safely call <code>.delete</code> from inside a for loop - something that might give you a challenge with a normal slice!</p><h2 id=key-difference-from-entity-component-systems>Key difference from Entity Component Systems</h2><p>If you are coming from other game engines which employ an Entity Component System (ECS), it&rsquo;s worth noting that Mach&rsquo;s object system is <em>NOT</em> an entity component system. It solves a lot of the same problems, we would argue with better tradeoffs, but it has key differences from common ECS approaches.</p><p>One key difference is that with an ECS, you have objects with <em>arbitrary components (struct fields) attached to them</em> - this can actually present a challenge when working with objects: you don&rsquo;t have a great way to say &lsquo;oh, a button must have <em>both</em> a text_label and a position`. Some ECS try to solve this with &lsquo;component bundles&rsquo;, but when getting an individual object you then still don&rsquo;t have a great way to say &lsquo;it has to have both components&rsquo;.</p><p>Mach&rsquo;s object system instead has rigid data types, literally a struct with fields:</p><pre tabindex=0><code>monsters: mach.Objects(struct {
    health: f32,
    damage: f32,
}),
</code></pre><p>Now, you might be wondering &lsquo;but what if I have an object someone else created, and I know it&rsquo;s not great but I need to attach some data to it without modifying that rigid data type? I don&rsquo;t want to modify that code&rsquo; - this is where <em>object relations</em> come in: we allow you to arbitrarily attach objects <em>of different types / from different lists</em> to eachother.</p><h2 id=continue-reading-relations>Continue reading: relations</h2><p><a href=../relations>Object system: relations</a></p></div><div class=toc><h3>Table of contents</h3><nav id=TableOfContents><ul><li><a href=#performance--philosophy>Performance & philosophy</a></li><li><a href=#object-ids>Object IDs</a></li><li><a href=#memory-allocation>Memory allocation</a></li><li><a href=#synchronization-and-multi-threading>Synchronization and multi-threading</a></li><li><a href=#iterating-objects>Iterating objects</a></li><li><a href=#key-difference-from-entity-component-systems>Key difference from Entity Component Systems</a></li><li><a href=#continue-reading-relations>Continue reading: relations</a></li></ul></nav></div></main><div class=footer><a href=https://hexops.com/privacy>Privacy matters</a><p><a href=https://github.com/hexops/machengine.org/archive/refs/heads/gh-pages.zip>offline version of this site</a> | <a href=https://machengine.org//about#improve-this-site>Improve this site</a> | <a href=https://github.com/sponsors/emidoots>Sponsor on GitHub</a> | <a href=https://devlog.hexops.com/>Hexops' devlog</a></p></div></div></body></html>